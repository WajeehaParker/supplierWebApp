{"ast":null,"code":"import { Children, createElement, cloneElement, Component } from 'react';\nimport { findDOMNode } from 'react-dom';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\n\nvar TableVerticalScrollbar =\n/** @class */\nfunction (_super) {\n  __extends(TableVerticalScrollbar, _super);\n\n  function TableVerticalScrollbar(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.minHeight = 15;\n\n    _this.onMouseDown = function (event) {\n      event.preventDefault();\n      _this.isMoving = true;\n      _this.previousMoveClientY = event.clientY;\n    };\n\n    _this.onMouseMove = function (event) {\n      var scrollTo = _this.props.scrollTo;\n      var _a = _this.state,\n          containerHeight = _a.containerHeight,\n          theadHeight = _a.theadHeight,\n          scrollbarHeight = _a.scrollbarHeight;\n\n      if (!_this.isMoving) {\n        return;\n      }\n\n      event.preventDefault();\n      var currentMoveClientY = event.clientY;\n      var deltaY = currentMoveClientY - _this.previousMoveClientY;\n      var scrollbarMoveableDistance = containerHeight - theadHeight - scrollbarHeight;\n      scrollTo = scrollbarMoveableDistance ? (scrollbarMoveableDistance * scrollTo + deltaY) / scrollbarMoveableDistance : 0;\n      scrollTo = Math.max(0, Math.min(scrollTo, 1));\n      _this.previousMoveClientY = currentMoveClientY;\n\n      _this.props.onScroll(scrollTo);\n    };\n\n    _this.onMouseUp = function (event) {\n      if (!_this.isMoving) {\n        return;\n      }\n\n      event.preventDefault();\n      _this.isMoving = false;\n      _this.previousMoveClientY = 0;\n    };\n\n    _this.onMouseOver = function () {\n      _this.setState({\n        focused: true\n      });\n    };\n\n    _this.onMouseOut = function () {\n      _this.setState({\n        focused: false\n      });\n    };\n\n    _this.state = {\n      focused: false,\n      containerHeight: 0,\n      tableHeight: 0,\n      theadHeight: 0,\n      scrollbarHeight: 0\n    };\n    _this.isMoving = false;\n    _this.previousMoveClientY = 0;\n    return _this;\n  }\n\n  TableVerticalScrollbar.prototype.componentDidMount = function () {\n    this.calculateDimensions();\n    this.scrollbarRef.addEventListener(\"mousedown\", this.onMouseDown);\n    window.addEventListener(\"mousemove\", this.onMouseMove);\n    window.addEventListener(\"mouseup\", this.onMouseUp);\n  };\n\n  TableVerticalScrollbar.prototype.componentWillUnmount = function () {\n    this.scrollbarRef.removeEventListener(\"mousedown\", this.onMouseDown);\n    window.removeEventListener(\"mousemove\", this.onMouseMove);\n    window.removeEventListener(\"mouseup\", this.onMouseUp);\n  };\n\n  TableVerticalScrollbar.prototype.componentDidUpdate = function () {\n    var _a = this.props,\n        containerRef = _a.containerRef,\n        tableRef = _a.tableRef;\n    var _b = this.state,\n        containerHeight = _b.containerHeight,\n        tableHeight = _b.tableHeight;\n    var newContainerHeight = containerRef.getBoundingClientRect().height;\n    var newTableHeight = findDOMNode(tableRef).getBoundingClientRect().height;\n\n    if (containerHeight !== newContainerHeight || tableHeight !== newTableHeight) {\n      this.calculateDimensions();\n    }\n  };\n\n  TableVerticalScrollbar.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        style = _a.style,\n        tableRef = _a.tableRef,\n        scrollTo = _a.scrollTo;\n    var _b = this.state,\n        focused = _b.focused,\n        containerHeight = _b.containerHeight,\n        tableHeight = _b.tableHeight,\n        theadHeight = _b.theadHeight,\n        scrollbarHeight = _b.scrollbarHeight;\n    var isScrollable = tableRef ? containerHeight - theadHeight < tableHeight - theadHeight : false;\n    var scrollbarContainerStyle = {\n      display: isScrollable ? \"block\" : \"none\",\n      boxSizing: \"border-box\",\n      position: \"absolute\",\n      top: theadHeight,\n      right: 0,\n      bottom: 0,\n      backgroundColor: \"#E3E5EB\",\n      width: 8\n    };\n    scrollbarContainerStyle = style ? focused ? _assign({}, scrollbarContainerStyle, style.backgroundFocus) : _assign({}, scrollbarContainerStyle, style.background) : scrollbarContainerStyle;\n    var scrollbarPositionTop = (containerHeight - theadHeight - scrollbarHeight) * scrollTo;\n    var scrollbarStyle = {\n      boxSizing: \"border-box\",\n      position: \"absolute\",\n      top: scrollbarPositionTop,\n      right: 0,\n      backgroundColor: \"#888C97\",\n      borderRadius: 4,\n      width: 8,\n      height: scrollbarHeight\n    };\n    scrollbarStyle = style ? focused ? _assign({}, scrollbarStyle, style.foregroundFocus) : _assign({}, scrollbarStyle, style.foreground) : scrollbarStyle;\n    return createElement(\"div\", {\n      style: scrollbarContainerStyle,\n      onMouseOver: this.onMouseOver,\n      onMouseOut: this.onMouseOut\n    }, createElement(\"div\", {\n      ref: function ref(_ref) {\n        return _this.scrollbarRef = _ref;\n      },\n      style: scrollbarStyle\n    }));\n  };\n\n  TableVerticalScrollbar.prototype.calculateDimensions = function () {\n    var _a = this.props,\n        containerRef = _a.containerRef,\n        tableRef = _a.tableRef;\n\n    if (!containerRef || !tableRef) {\n      return;\n    }\n\n    var containerHeight = containerRef.getBoundingClientRect().height;\n    var tableElement = findDOMNode(tableRef);\n    var tableHeight = tableElement.getBoundingClientRect().height;\n    var theadHeight = tableElement.querySelector(\"thead\").getBoundingClientRect().height;\n    var noHeaderTableHeight = tableHeight - theadHeight;\n    var visibleContainerHeight = containerHeight - theadHeight;\n    var scrollbarHeight = noHeaderTableHeight ? Math.pow(visibleContainerHeight, 2) / noHeaderTableHeight : 0;\n    scrollbarHeight = Math.max(this.minHeight, Math.min(scrollbarHeight, visibleContainerHeight));\n    this.setState({\n      containerHeight: containerHeight,\n      tableHeight: tableHeight,\n      theadHeight: theadHeight,\n      scrollbarHeight: scrollbarHeight\n    });\n  };\n\n  return TableVerticalScrollbar;\n}(Component);\n\nvar TableHorizontalScrollbar =\n/** @class */\nfunction (_super) {\n  __extends(TableHorizontalScrollbar, _super);\n\n  function TableHorizontalScrollbar(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.minHeight = 15;\n\n    _this.onMouseDown = function (event) {\n      event.preventDefault();\n      _this.isMoving = true;\n      _this.previousMoveClientX = event.clientX;\n    };\n\n    _this.onMouseMove = function (event) {\n      var scrollTo = _this.props.scrollTo;\n      var _a = _this.state,\n          containerWidth = _a.containerWidth,\n          scrollbarWidth = _a.scrollbarWidth;\n\n      if (!_this.isMoving) {\n        return;\n      }\n\n      event.preventDefault();\n      var currentMoveClientX = event.clientX;\n      var deltaX = currentMoveClientX - _this.previousMoveClientX;\n      var scrollbarMoveableDistance = containerWidth - scrollbarWidth;\n      scrollTo = scrollbarMoveableDistance ? (scrollbarMoveableDistance * scrollTo + deltaX) / scrollbarMoveableDistance : 0;\n      scrollTo = Math.max(0, Math.min(scrollTo, 1));\n      _this.previousMoveClientX = currentMoveClientX;\n\n      _this.props.onScroll(scrollTo);\n    };\n\n    _this.onMouseUp = function (event) {\n      if (!_this.isMoving) {\n        return;\n      }\n\n      event.preventDefault();\n      _this.isMoving = false;\n      _this.previousMoveClientX = 0;\n    };\n\n    _this.onMouseOver = function () {\n      _this.setState({\n        focused: true\n      });\n    };\n\n    _this.onMouseOut = function () {\n      _this.setState({\n        focused: false\n      });\n    };\n\n    _this.state = {\n      focused: false,\n      containerWidth: 0,\n      tableWidth: 0,\n      scrollbarWidth: 0\n    };\n    _this.isMoving = false;\n    _this.previousMoveClientX = 0;\n    return _this;\n  }\n\n  TableHorizontalScrollbar.prototype.componentDidMount = function () {\n    this.calculateDimensions();\n    this.scrollbarRef.addEventListener(\"mousedown\", this.onMouseDown);\n    window.addEventListener(\"mousemove\", this.onMouseMove);\n    window.addEventListener(\"mouseup\", this.onMouseUp);\n  };\n\n  TableHorizontalScrollbar.prototype.componentWillUnmount = function () {\n    this.scrollbarRef.removeEventListener(\"mousedown\", this.onMouseDown);\n    window.removeEventListener(\"mousemove\", this.onMouseMove);\n    window.removeEventListener(\"mouseup\", this.onMouseUp);\n  };\n\n  TableHorizontalScrollbar.prototype.componentDidUpdate = function () {\n    var _a = this.props,\n        containerRef = _a.containerRef,\n        tableRef = _a.tableRef;\n    var _b = this.state,\n        containerWidth = _b.containerWidth,\n        tableWidth = _b.tableWidth;\n    var newContainerWidth = containerRef.getBoundingClientRect().width;\n    var newTableWidth = findDOMNode(tableRef).getBoundingClientRect().width;\n\n    if (containerWidth !== newContainerWidth || tableWidth !== newTableWidth) {\n      this.calculateDimensions();\n    }\n  };\n\n  TableHorizontalScrollbar.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        style = _a.style,\n        tableRef = _a.tableRef,\n        scrollTo = _a.scrollTo;\n    var _b = this.state,\n        focused = _b.focused,\n        containerWidth = _b.containerWidth,\n        tableWidth = _b.tableWidth,\n        scrollbarWidth = _b.scrollbarWidth;\n    var isScrollable = tableRef ? containerWidth < tableWidth : false;\n    var scrollbarContainerStyle = {\n      display: isScrollable ? \"block\" : \"none\",\n      boxSizing: \"border-box\",\n      position: \"absolute\",\n      right: 0,\n      bottom: 0,\n      left: 0,\n      backgroundColor: \"#E3E5EB\",\n      height: 8\n    };\n    scrollbarContainerStyle = style ? focused ? _assign({}, scrollbarContainerStyle, style.backgroundFocus) : _assign({}, scrollbarContainerStyle, style.background) : scrollbarContainerStyle;\n    var scrollbarPositionLeft = (containerWidth - scrollbarWidth) * scrollTo;\n    var scrollbarStyle = {\n      boxSizing: \"border-box\",\n      position: \"absolute\",\n      bottom: 0,\n      left: scrollbarPositionLeft,\n      backgroundColor: \"#888C97\",\n      borderRadius: 4,\n      width: scrollbarWidth,\n      height: 8\n    };\n    scrollbarStyle = style ? focused ? _assign({}, scrollbarStyle, style.foregroundFocus) : _assign({}, scrollbarStyle, style.foreground) : scrollbarStyle;\n    return createElement(\"div\", {\n      style: scrollbarContainerStyle,\n      onMouseOver: this.onMouseOver,\n      onMouseOut: this.onMouseOut\n    }, createElement(\"div\", {\n      ref: function ref(_ref2) {\n        return _this.scrollbarRef = _ref2;\n      },\n      style: scrollbarStyle\n    }));\n  };\n\n  TableHorizontalScrollbar.prototype.calculateDimensions = function () {\n    var _a = this.props,\n        containerRef = _a.containerRef,\n        tableRef = _a.tableRef;\n\n    if (!containerRef || !tableRef) {\n      return;\n    }\n\n    var containerWidth = containerRef.getBoundingClientRect().width;\n    var tableWidth = findDOMNode(tableRef).getBoundingClientRect().width;\n    var scrollbarWidth = tableWidth ? Math.pow(containerWidth, 2) / tableWidth : 0;\n    scrollbarWidth = Math.max(this.minHeight, Math.min(scrollbarWidth, containerWidth));\n    this.setState({\n      containerWidth: containerWidth,\n      tableWidth: tableWidth,\n      scrollbarWidth: scrollbarWidth\n    });\n  };\n\n  return TableHorizontalScrollbar;\n}(Component);\n\nvar ReactTableContainer =\n/** @class */\nfunction (_super) {\n  __extends(ReactTableContainer, _super);\n\n  function ReactTableContainer(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.tableId = \"main-table\";\n    _this.headerTableId = \"header-table\";\n    _this.headerRelatedHTMLElements = [\"colgroup\", \"thead\"];\n    _this.timeoutId = null;\n\n    _this.onWindowResize = function () {\n      clearTimeout(_this.timeoutId);\n      _this.timeoutId = setTimeout(_this.reevaluateDimensions, 16);\n    }; // Make the header table's header cells the same width as the main table's header cells\n\n\n    _this.refreshHeaders = function () {\n      var headerTableHeaderRow = findDOMNode(_this.headerTableRef).querySelector(\"thead > tr:first-child\");\n      var tableHeaderRow = findDOMNode(_this.tableRef).querySelector(\"thead > tr:first-child\");\n\n      if (headerTableHeaderRow && tableHeaderRow) {\n        var cellsWidth = []; // All necessary reads are done first for increased performance\n\n        for (var i = 0; i < tableHeaderRow.children.length; i++) {\n          cellsWidth.push(tableHeaderRow.children.item(i).getBoundingClientRect().width);\n        }\n\n        for (var i = 0; i < tableHeaderRow.children.length; i++) {\n          var item = headerTableHeaderRow.children.item(i);\n          item.style.boxSizing = \"border-box\";\n          item.style.minWidth = cellsWidth[i] + \"px\";\n        }\n      }\n    }; // Update dimensions if they have changed\n\n\n    _this.reevaluateDimensions = function () {\n      var _a = _this.state,\n          containerWidth = _a.containerWidth,\n          containerHeight = _a.containerHeight,\n          tableWidth = _a.tableWidth,\n          tableHeight = _a.tableHeight; // `getBoundingClientRect` can be called directly on the ref instance since it holds a DIV element instance\n\n      var containerBoundingClientRect = _this.containerRef.getBoundingClientRect();\n\n      var tableBoundingClientRect = findDOMNode(_this.tableRef).getBoundingClientRect();\n      var newContainerWidth = containerBoundingClientRect.width;\n      var newContainerHeight = containerBoundingClientRect.height;\n      var newTableWidth = tableBoundingClientRect.width;\n      var newTableHeight = tableBoundingClientRect.height;\n\n      if (containerWidth !== newContainerWidth || containerHeight !== newContainerHeight || tableWidth !== newTableWidth || tableHeight !== newTableHeight) {\n        _this.applyDimensions({\n          containerWidth: newContainerWidth,\n          containerHeight: newContainerHeight,\n          tableWidth: newTableWidth,\n          tableHeight: newTableHeight\n        });\n      }\n    };\n\n    _this.onWheel = function (event) {\n      event.preventDefault();\n      var _a = _this.state,\n          containerWidth = _a.containerWidth,\n          containerHeight = _a.containerHeight,\n          tableWidth = _a.tableWidth,\n          tableHeight = _a.tableHeight,\n          tableMarginTop = _a.tableMarginTop,\n          verticalPercentageScrolled = _a.verticalPercentageScrolled,\n          tableMarginLeft = _a.tableMarginLeft,\n          horizontalPercentageScrolled = _a.horizontalPercentageScrolled;\n      var deltaY = event.deltaY;\n      var deltaX = event.deltaX; // Adjust if the delta values are specified in lines\n\n      if (event.deltaMode === 1) {\n        deltaY *= 10;\n        deltaX *= 10;\n      } // Get vertical properties\n\n\n      var verticalMaxScrollable = Math.max(0, tableHeight - containerHeight);\n      var newTableMarginTop = tableMarginTop + deltaY; // Get horizontal properties\n\n      var horizontalMaxScrollable = Math.max(0, tableWidth - containerWidth);\n      var newTableMarginLeft = tableMarginLeft + deltaX;\n\n      _this.setWindowScroll(verticalMaxScrollable, newTableMarginTop, horizontalMaxScrollable, newTableMarginLeft); // Set vertical properties\n\n\n      tableMarginTop = Math.max(0, Math.min(newTableMarginTop, verticalMaxScrollable));\n      verticalPercentageScrolled = verticalMaxScrollable ? tableMarginTop / verticalMaxScrollable : 0; // Set horizontal properties\n\n      tableMarginLeft = Math.max(0, Math.min(newTableMarginLeft, horizontalMaxScrollable));\n      horizontalPercentageScrolled = horizontalMaxScrollable ? tableMarginLeft / horizontalMaxScrollable : 0;\n\n      _this.setState({\n        tableMarginTop: tableMarginTop,\n        verticalPercentageScrolled: verticalPercentageScrolled,\n        tableMarginLeft: tableMarginLeft,\n        horizontalPercentageScrolled: horizontalPercentageScrolled\n      });\n    };\n\n    _this.onTouchStart = function (event) {\n      _this.setState({\n        isMoving: true,\n        previousSwipeClientX: event.changedTouches[0].clientX,\n        previousSwipeClientY: event.changedTouches[0].clientY\n      });\n    };\n\n    _this.onTouchMove = function (event) {\n      event.preventDefault();\n      var _a = _this.state,\n          containerWidth = _a.containerWidth,\n          containerHeight = _a.containerHeight,\n          tableWidth = _a.tableWidth,\n          tableHeight = _a.tableHeight,\n          tableMarginTop = _a.tableMarginTop,\n          tableMarginLeft = _a.tableMarginLeft,\n          isMoving = _a.isMoving,\n          previousSwipeClientX = _a.previousSwipeClientX,\n          previousSwipeClientY = _a.previousSwipeClientY;\n\n      if (!isMoving) {\n        return;\n      } // Get vertical properties\n\n\n      var verticalMaxScrollable = Math.max(0, tableHeight - containerHeight);\n      var currentSwipeClientY = event.changedTouches[0].clientY;\n      var deltaY = previousSwipeClientY - currentSwipeClientY;\n      var newTableMarginTop = tableMarginTop + deltaY; // Get horizontal properties\n\n      var horizontalMaxScrollable = Math.max(0, tableWidth - containerWidth);\n      var currentSwipeClientX = event.changedTouches[0].clientX;\n      var deltaX = previousSwipeClientX - currentSwipeClientX;\n      var newTableMarginLeft = tableMarginLeft + deltaX;\n\n      _this.setWindowScroll(verticalMaxScrollable, newTableMarginTop, horizontalMaxScrollable, newTableMarginLeft); // Set vertical properties\n\n\n      tableMarginTop = Math.max(0, Math.min(newTableMarginTop, verticalMaxScrollable));\n      var verticalPercentageScrolled = verticalMaxScrollable ? tableMarginTop / verticalMaxScrollable : 0;\n      previousSwipeClientY = currentSwipeClientY; // Set horizontal properties\n\n      tableMarginLeft = Math.max(0, Math.min(newTableMarginLeft, horizontalMaxScrollable));\n      var horizontalPercentageScrolled = horizontalMaxScrollable ? tableMarginLeft / horizontalMaxScrollable : 0;\n      previousSwipeClientX = currentSwipeClientX;\n\n      _this.setState({\n        tableMarginTop: tableMarginTop,\n        verticalPercentageScrolled: verticalPercentageScrolled,\n        tableMarginLeft: tableMarginLeft,\n        horizontalPercentageScrolled: horizontalPercentageScrolled,\n        previousSwipeClientY: previousSwipeClientY,\n        previousSwipeClientX: previousSwipeClientX\n      });\n    };\n\n    _this.onTouchEnd = function (event) {\n      _this.setState({\n        isMoving: false,\n        previousSwipeClientX: 0,\n        previousSwipeClientY: 0\n      });\n    };\n\n    _this.onVerticalScroll = function (scrollTo) {\n      var _a = _this.state,\n          containerHeight = _a.containerHeight,\n          tableHeight = _a.tableHeight;\n      var maxScrollable = tableHeight - containerHeight;\n      var tableMarginTop = Math.max(0, Math.min(scrollTo * maxScrollable, maxScrollable));\n\n      _this.setState({\n        tableMarginTop: tableMarginTop,\n        verticalPercentageScrolled: scrollTo\n      });\n    };\n\n    _this.onHorizontalScroll = function (scrollTo) {\n      var _a = _this.state,\n          containerWidth = _a.containerWidth,\n          tableWidth = _a.tableWidth;\n      var maxScrollable = tableWidth - containerWidth;\n      var tableMarginLeft = Math.max(0, Math.min(scrollTo * maxScrollable, maxScrollable));\n\n      _this.setState({\n        tableMarginLeft: tableMarginLeft,\n        horizontalPercentageScrolled: scrollTo\n      });\n    }; // Some of the state below could possibly be converted into instance properties, as they don't seem to directly play a role during any rendering\n\n\n    _this.state = {\n      containerWidth: 0,\n      containerHeight: 0,\n      tableWidth: 0,\n      tableHeight: 0,\n      tableMarginTop: 0,\n      verticalPercentageScrolled: 0,\n      tableMarginLeft: 0,\n      horizontalPercentageScrolled: 0,\n      isMoving: false,\n      previousSwipeClientX: 0,\n      previousSwipeClientY: 0\n    };\n    return _this;\n  }\n\n  ReactTableContainer.prototype.componentDidMount = function () {\n    // Set up the Main Table\n    this.tableElement = findDOMNode(this.tableRef); // Register listeners\n\n    this.tableElement.addEventListener(\"wheel\", this.onWheel);\n    this.tableElement.addEventListener(\"touchstart\", this.onTouchStart);\n    this.tableElement.addEventListener(\"touchmove\", this.onTouchMove);\n    this.tableElement.addEventListener(\"touchend\", this.onTouchEnd);\n    this.tableElement.addEventListener(\"touchcancel\", this.onTouchEnd);\n    window.addEventListener(\"resize\", this.onWindowResize); // `getBoundingClientRect` can be called directly on the ref instance since it holds a DIV element instance\n\n    var containerBoundingClientRect = this.containerRef.getBoundingClientRect();\n    var tableBoundingClientRect = this.tableElement.getBoundingClientRect(); // Apply initial dimensions\n\n    this.applyDimensions({\n      containerWidth: containerBoundingClientRect.width,\n      containerHeight: containerBoundingClientRect.height,\n      tableWidth: tableBoundingClientRect.width,\n      tableHeight: tableBoundingClientRect.height\n    }); // Refs (which aren't null at this stage) must be propagated onto the scrollbar components.\n    // This could be achieved using `this.forceUpdate()` but the `this.applyDimensions` method above already triggers the required re-render.\n  };\n\n  ReactTableContainer.prototype.componentWillUnmount = function () {\n    // Remove listeners\n    this.tableElement.removeEventListener(\"wheel\", this.onWheel);\n    this.tableElement.removeEventListener(\"touchstart\", this.onTouchStart);\n    this.tableElement.removeEventListener(\"touchmove\", this.onTouchMove);\n    this.tableElement.removeEventListener(\"touchend\", this.onTouchEnd);\n    this.tableElement.removeEventListener(\"touchcancel\", this.onTouchEnd);\n    window.removeEventListener(\"resize\", this.onWindowResize);\n  };\n\n  ReactTableContainer.prototype.componentDidUpdate = function () {\n    this.refreshHeaders();\n    this.reevaluateDimensions();\n  };\n\n  ReactTableContainer.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        children = _a.children,\n        style = _a.style,\n        className = _a.className,\n        width = _a.width,\n        height = _a.height,\n        customHeader = _a.customHeader,\n        scrollbarStyle = _a.scrollbarStyle;\n    var _b = this.state,\n        tableMarginTop = _b.tableMarginTop,\n        verticalPercentageScrolled = _b.verticalPercentageScrolled,\n        tableMarginLeft = _b.tableMarginLeft,\n        horizontalPercentageScrolled = _b.horizontalPercentageScrolled;\n    var containerStyle = {\n      boxSizing: \"border-box\",\n      position: \"relative\",\n      display: \"inline-block\",\n      overflow: \"hidden\",\n      width: width,\n      height: height\n    };\n    var containerProps = {\n      ref: function ref(_ref3) {\n        return _this.containerRef = _ref3;\n      },\n      style: _assign({}, style, containerStyle),\n      className: className\n    }; // Only one direct child (i.e. <table>) is allowed\n\n    var table = Children.only(children); // Set table props\n\n    var tableProps = _assign({}, table.props, {\n      ref: function ref(_ref4) {\n        return _this.tableRef = _ref4;\n      },\n      \"data-rtc-id\": this.tableId,\n      style: _assign({}, table.props.style, {\n        borderSpacing: 0,\n        marginTop: -tableMarginTop,\n        marginLeft: -tableMarginLeft\n      })\n    }); // Set header table props\n\n\n    var headerTableProps = _assign({}, table.props, {\n      ref: function ref(_ref5) {\n        return _this.headerTableRef = _ref5;\n      },\n      \"data-rtc-id\": this.headerTableId,\n      style: _assign({}, table.props.style, {\n        borderSpacing: 0,\n        position: \"absolute\",\n        top: 0,\n        left: -tableMarginLeft,\n        zIndex: 1\n      }),\n      role: \"presentation\",\n      \"aria-hidden\": \"true\"\n    });\n\n    var tableChildren = Children.toArray(table.props.children);\n    var headerRelatedItems = customHeader ? __spread(this.headerRelatedHTMLElements, customHeader) : this.headerRelatedHTMLElements; // Extract out header related children\n\n    var headerRelatedChildren = tableChildren.filter(function (_a) {\n      var type = _a.type;\n      return headerRelatedItems.indexOf(type) !== -1;\n    });\n    return createElement(\"div\", _assign({}, containerProps), cloneElement(table, headerTableProps, headerRelatedChildren), cloneElement(table, tableProps), createElement(TableVerticalScrollbar, {\n      style: scrollbarStyle,\n      containerRef: this.containerRef,\n      tableRef: this.tableRef,\n      scrollTo: verticalPercentageScrolled,\n      onScroll: this.onVerticalScroll\n    }), createElement(TableHorizontalScrollbar, {\n      style: scrollbarStyle,\n      containerRef: this.containerRef,\n      tableRef: this.tableRef,\n      scrollTo: horizontalPercentageScrolled,\n      onScroll: this.onHorizontalScroll\n    }));\n  }; // For instance, if the table gets wider, the horizontal scrollbar will remain in the same place, but the amount of percentage scrolled will be now be less\n\n\n  ReactTableContainer.prototype.applyDimensions = function (dimensions) {\n    var _a = this.state,\n        tableMarginTop = _a.tableMarginTop,\n        verticalPercentageScrolled = _a.verticalPercentageScrolled,\n        tableMarginLeft = _a.tableMarginLeft,\n        horizontalPercentageScrolled = _a.horizontalPercentageScrolled;\n    var verticalMaxScrollable = dimensions.tableHeight - dimensions.containerHeight;\n    tableMarginTop = Math.max(0, Math.min(tableMarginTop, verticalMaxScrollable));\n    verticalPercentageScrolled = verticalMaxScrollable ? tableMarginTop / verticalMaxScrollable : 0;\n    var horizontalMaxScrollable = dimensions.tableWidth - dimensions.containerWidth;\n    tableMarginLeft = Math.max(0, Math.min(tableMarginLeft, horizontalMaxScrollable));\n    horizontalPercentageScrolled = horizontalMaxScrollable ? tableMarginLeft / horizontalMaxScrollable : 0;\n    this.setState({\n      containerWidth: dimensions.containerWidth,\n      containerHeight: dimensions.containerHeight,\n      tableWidth: dimensions.tableWidth,\n      tableHeight: dimensions.tableHeight,\n      tableMarginTop: tableMarginTop,\n      verticalPercentageScrolled: verticalPercentageScrolled,\n      tableMarginLeft: tableMarginLeft,\n      horizontalPercentageScrolled: horizontalPercentageScrolled\n    });\n  }; // If scrolling within the table hits any boundary, propagate it onto the window object\n\n\n  ReactTableContainer.prototype.setWindowScroll = function (verticalMaxScrollable, newTableMarginTop, horizontalMaxScrollable, newTableMarginLeft) {\n    var scrollByX = 0;\n    var scrollByY = 0;\n\n    if (newTableMarginTop < 0) {\n      scrollByY = newTableMarginTop;\n    } else if (newTableMarginTop > verticalMaxScrollable) {\n      scrollByY = newTableMarginTop - verticalMaxScrollable;\n    }\n\n    if (newTableMarginLeft < 0) {\n      scrollByX = newTableMarginLeft;\n    } else if (newTableMarginLeft > horizontalMaxScrollable) {\n      scrollByX = newTableMarginLeft - horizontalMaxScrollable;\n    }\n\n    window.scrollBy(scrollByX, scrollByY);\n  };\n\n  return ReactTableContainer;\n}(Component);\n\nexport default ReactTableContainer;","map":null,"metadata":{},"sourceType":"module"}